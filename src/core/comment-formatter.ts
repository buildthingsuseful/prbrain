import { 
  PRAnalysisResult, 
  AIDetectionResult, 
  IntentExtractionResult,
  DeduplicationResult,
  VisionAlignmentResult,
  QualityScoreResult 
} from '../types';

export class CommentFormatter {
  formatAnalysis(analysis: PRAnalysisResult): string {
    const sections: string[] = [];

    // Header
    sections.push('## üß† PRBrain Analysis');
    sections.push('');

    // AI Detection
    sections.push(this.formatAIDetection(analysis.aiDetection));
    sections.push('');

    // Intent and Summary
    sections.push(this.formatIntentExtraction(analysis.intentExtraction));
    sections.push('');

    // Similar PRs/Issues (if any)
    if (analysis.deduplication.similarItems.length > 0) {
      sections.push(this.formatDeduplication(analysis.deduplication));
      sections.push('');
    }

    // Vision Alignment (if vision document exists)
    if (analysis.visionAlignment.visionFound) {
      sections.push(this.formatVisionAlignment(analysis.visionAlignment));
      sections.push('');
    }

    // Quality Score
    sections.push(this.formatQualityScore(analysis.qualityScore));

    // Footer
    sections.push('');
    sections.push('---');
    sections.push('*This analysis was generated by PRBrain - AI-powered PR analysis*');

    return sections.join('\n');
  }

  private formatAIDetection(detection: AIDetectionResult): string {
    const emoji = detection.isAIGenerated ? 'ü§ñ' : 'üë®‚Äçüíª';
    const label = detection.isAIGenerated ? 'AI-Generated' : 'Human-Written';
    const confidence = detection.confidence;
    
    let confidenceLabel = '';
    if (confidence >= 90) confidenceLabel = 'Very High';
    else if (confidence >= 70) confidenceLabel = 'High';
    else if (confidence >= 50) confidenceLabel = 'Medium';
    else if (confidence >= 30) confidenceLabel = 'Low';
    else confidenceLabel = 'Very Low';

    let result = `${emoji} **${label}:** ${confidenceLabel} (${confidence}%)`;

    // Add top signals if AI is detected
    if (detection.isAIGenerated && detection.signals.length > 0) {
      const topSignals = detection.signals
        .filter(s => s.score >= 0.5)
        .slice(0, 3)
        .map(s => s.indicator)
        .join(', ');
      
      if (topSignals) {
        result += `\n> ${topSignals}`;
      }
    }

    return result;
  }

  private formatIntentExtraction(intent: IntentExtractionResult): string {
    const sections: string[] = [];
    
    sections.push(`üí° **Prompt Intent:** ${intent.inferredIntent}`);
    sections.push('');
    sections.push(`**What it does:** ${intent.summary}`);
    sections.push('');
    sections.push(`**Scope:** ${intent.scope.description}`);

    if (intent.keyChanges.length > 0) {
      sections.push('');
      sections.push('**Changes:**');
      intent.keyChanges.slice(0, 5).forEach(change => {
        sections.push(`- ${change}`);
      });
    }

    if (intent.gaps.length > 0) {
      sections.push('');
      sections.push('**‚ö†Ô∏è Gaps:**');
      intent.gaps.forEach(gap => {
        sections.push(`- ${gap}`);
      });
    }

    return sections.join('\n');
  }

  private formatDeduplication(dedup: DeduplicationResult): string {
    const sections: string[] = [];
    
    if (dedup.isDuplicate) {
      sections.push('### üö® Duplicate Detected');
    } else {
      sections.push('### üîÑ Similar PRs/Issues');
    }

    const topSimilar = dedup.similarItems.slice(0, 5);
    
    for (const item of topSimilar) {
      const typeEmoji = item.type === 'pr' ? 'üîÄ' : 'üìã';
      const statusEmoji = this.getStatusEmoji(item.status);
      const similarity = Math.round(item.similarity * 100);
      
      sections.push(`- ${typeEmoji} #${item.number} "${item.title}" (${similarity}% similar) ‚Äî ${statusEmoji} ${item.status.toUpperCase()}`);
    }

    return sections.join('\n');
  }

  private formatVisionAlignment(vision: VisionAlignmentResult): string {
    const sections: string[] = [];
    
    sections.push('### üìê Vision Alignment');
    
    if (vision.isAligned) {
      sections.push(`‚úÖ Aligned with project goals (${vision.score}/100)`);
    } else {
      sections.push(`‚ùå Potential misalignment (${vision.score}/100)`);
    }

    // Show specific alignments if available
    const aligned = vision.alignment.filter(a => a.alignment === 'aligned');
    const misaligned = vision.alignment.filter(a => a.alignment === 'misaligned');

    if (aligned.length > 0) {
      sections.push('**Supports:**');
      aligned.forEach(item => {
        sections.push(`  ‚Ä¢ ${item.principle}`);
      });
    }

    if (misaligned.length > 0) {
      sections.push('**Concerns:**');
      misaligned.forEach(item => {
        sections.push(`  ‚Ä¢ ${item.principle}: ${item.reasoning}`);
      });
    }

    return sections.join('\n');
  }

  private formatQualityScore(quality: QualityScoreResult): string {
    const sections: string[] = [];
    
    sections.push(`### üìä Quality Score: ${quality.overallScore}/${quality.maxScore}`);
    
    sections.push('');

    // Group factors by status
    const passingFactors = quality.factors.filter(f => f.status === 'pass');
    const warningFactors = quality.factors.filter(f => f.status === 'warning');
    const failingFactors = quality.factors.filter(f => f.status === 'fail');

    // Show failures and warnings first, then passes
    if (failingFactors.length > 0) {
      failingFactors.forEach(factor => {
        sections.push(`- ‚ùå ${factor.description}`);
      });
    }

    if (warningFactors.length > 0) {
      warningFactors.forEach(factor => {
        sections.push(`- ‚ö†Ô∏è ${factor.description}`);
      });
    }

    if (passingFactors.length > 0) {
      passingFactors.forEach(factor => {
        sections.push(`- ‚úÖ ${factor.description}`);
      });
    }

    return sections.join('\n');
  }

  private getStatusEmoji(status: string): string {
    switch (status.toLowerCase()) {
      case 'open':
        return 'üü¢';
      case 'closed':
        return 'üî¥';
      case 'merged':
        return 'üíú';
      case 'draft':
        return 'üìù';
      default:
        return '‚ö™';
    }
  }

  /**
   * Format a compact summary for notifications or quick views
   */
  formatCompactSummary(analysis: PRAnalysisResult): string {
    const parts: string[] = [];

    // AI detection
    const aiEmoji = analysis.aiDetection.isAIGenerated ? 'ü§ñ' : 'üë®‚Äçüíª';
    parts.push(`${aiEmoji} ${analysis.aiDetection.confidence}%`);

    // Quality score
    parts.push(`üìä ${analysis.qualityScore.overallScore}/10`);

    // Duplicates
    if (analysis.deduplication.isDuplicate) {
      parts.push('üö® DUPLICATE');
    } else if (analysis.deduplication.similarItems.length > 0) {
      parts.push(`üîÑ ${analysis.deduplication.similarItems.length} similar`);
    }

    // Vision alignment
    if (analysis.visionAlignment.visionFound && !analysis.visionAlignment.isAligned) {
      parts.push('üìê Misaligned');
    }

    return `PRBrain: ${parts.join(' | ')}`;
  }

  /**
   * Format analysis for different platforms (Discord, Slack, etc.)
   */
  formatForPlatform(analysis: PRAnalysisResult, platform: 'github' | 'discord' | 'slack' | 'webhook'): string {
    switch (platform) {
      case 'discord':
        return this.formatForDiscord(analysis);
      case 'slack':
        return this.formatForSlack(analysis);
      case 'webhook':
        return this.formatForWebhook(analysis);
      default:
        return this.formatAnalysis(analysis);
    }
  }

  private formatForDiscord(analysis: PRAnalysisResult): string {
    // Discord has some markdown limitations, avoid tables
    const sections: string[] = [];
    
    sections.push('üß† **PRBrain Analysis**');
    sections.push('');
    
    // Key metrics in a more compact format
    const ai = analysis.aiDetection.isAIGenerated ? 'ü§ñ AI' : 'üë®‚Äçüíª Human';
    const confidence = analysis.aiDetection.confidence;
    const quality = analysis.qualityScore.overallScore;
    
    sections.push(`${ai} (${confidence}%) ‚Ä¢ Quality: ${quality}/10`);
    sections.push('');
    sections.push(`**Intent:** ${analysis.intentExtraction.inferredIntent}`);
    
    if (analysis.deduplication.similarItems.length > 0) {
      sections.push(`**Similar Items:** ${analysis.deduplication.similarItems.length} found`);
    }
    
    return sections.join('\n');
  }

  private formatForSlack(analysis: PRAnalysisResult): string {
    // Slack supports more formatting but we keep it clean
    const sections: string[] = [];
    
    sections.push('*üß† PRBrain Analysis*');
    sections.push('');
    
    const ai = analysis.aiDetection.isAIGenerated ? 'ü§ñ AI-Generated' : 'üë®‚Äçüíª Human-Written';
    sections.push(`${ai} (${analysis.aiDetection.confidence}% confidence)`);
    sections.push(`Quality Score: ${analysis.qualityScore.overallScore}/10`);
    sections.push('');
    sections.push(`*Intent:* ${analysis.intentExtraction.inferredIntent}`);
    
    return sections.join('\n');
  }

  private formatForWebhook(analysis: PRAnalysisResult): string {
    // JSON format for webhook consumption
    return JSON.stringify({
      summary: this.formatCompactSummary(analysis),
      aiGenerated: analysis.aiDetection.isAIGenerated,
      confidence: analysis.aiDetection.confidence,
      qualityScore: analysis.qualityScore.overallScore,
      intent: analysis.intentExtraction.inferredIntent,
      isDuplicate: analysis.deduplication.isDuplicate,
      similarCount: analysis.deduplication.similarItems.length,
      visionAligned: analysis.visionAlignment.isAligned,
      timestamp: new Date().toISOString(),
    }, null, 2);
  }

  /**
   * Format error message when analysis fails
   */
  formatError(error: Error): string {
    return `## üß† PRBrain Analysis - Error

‚ö†Ô∏è **Analysis Failed:** ${error.message}

PRBrain encountered an error while analyzing this PR. This might be due to:
- API rate limits
- Large diff size
- Network connectivity issues
- Configuration problems

Please check the action logs for more details and try again later.

---
*PRBrain - AI-powered PR analysis*`;
  }

  /**
   * Format partial analysis when some components fail
   */
  formatPartialAnalysis(analysis: Partial<PRAnalysisResult>, errors: string[]): string {
    const sections: string[] = [];
    
    sections.push('## üß† PRBrain Analysis - Partial Results');
    sections.push('');
    sections.push('‚ö†Ô∏è Some analysis components failed. Results shown are partial.');
    sections.push('');

    if (analysis.aiDetection) {
      sections.push(this.formatAIDetection(analysis.aiDetection));
      sections.push('');
    }

    if (analysis.intentExtraction) {
      sections.push(this.formatIntentExtraction(analysis.intentExtraction));
      sections.push('');
    }

    if (analysis.deduplication?.similarItems.length) {
      sections.push(this.formatDeduplication(analysis.deduplication));
      sections.push('');
    }

    if (analysis.visionAlignment?.visionFound) {
      sections.push(this.formatVisionAlignment(analysis.visionAlignment));
      sections.push('');
    }

    if (analysis.qualityScore) {
      sections.push(this.formatQualityScore(analysis.qualityScore));
      sections.push('');
    }

    // Show errors
    sections.push('### ‚ùå Analysis Errors');
    errors.forEach(error => {
      sections.push(`- ${error}`);
    });

    sections.push('');
    sections.push('---');
    sections.push('*PRBrain - AI-powered PR analysis*');

    return sections.join('\n');
  }
}