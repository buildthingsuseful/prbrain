import OpenAI from 'openai';
import { logger } from '../utils/logger';
import { TokenUsage } from '../types';

export class OpenAIAdapter {
  private client: OpenAI;
  private model: string;

  constructor(apiKey: string, model: string = 'gpt-4o-mini') {
    this.client = new OpenAI({
      apiKey,
    });
    this.model = model;
  }

  async generateCompletion(
    prompt: string,
    systemMessage?: string,
    options: {
      maxTokens?: number;
      temperature?: number;
      jsonMode?: boolean;
    } = {}
  ): Promise<{ content: string; usage: TokenUsage }> {
    const { maxTokens = 2000, temperature = 0.1, jsonMode = false } = options;

    try {
      logger.debug(`Making OpenAI completion request with model ${this.model}`);
      
      const messages: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [];
      
      if (systemMessage) {
        messages.push({ role: 'system', content: systemMessage });
      }
      
      messages.push({ role: 'user', content: prompt });

      const requestParams: any = {
        model: this.model,
        messages,
        max_tokens: maxTokens,
        temperature,
      };
      
      if (jsonMode) {
        requestParams.response_format = { type: 'json_object' };
      }

      const completion = await this.client.chat.completions.create(requestParams);

      const content = completion.choices[0]?.message?.content || '';
      const usage: TokenUsage = {
        input: completion.usage?.prompt_tokens || 0,
        output: completion.usage?.completion_tokens || 0,
        total: completion.usage?.total_tokens || 0,
      };

      logger.debug(`OpenAI completion used ${usage.total} tokens`);
      
      return { content, usage };
    } catch (error) {
      logger.error('OpenAI completion failed', error);
      throw new Error(`OpenAI API call failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async generateEmbedding(text: string): Promise<{ embedding: number[]; usage: TokenUsage }> {
    try {
      logger.debug('Generating embedding');
      
      const response = await this.client.embeddings.create({
        model: 'text-embedding-3-small',
        input: text,
      });

      const embedding = response.data[0]?.embedding || [];
      const usage: TokenUsage = {
        input: response.usage.prompt_tokens,
        output: 0,
        total: response.usage.total_tokens,
      };

      return { embedding, usage };
    } catch (error) {
      logger.error('OpenAI embedding failed', error);
      throw new Error(`OpenAI embedding failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async extractIntent(diff: string, title: string, body: string | null): Promise<{
    intent: string;
    summary: string;
    confidence: number;
    keyChanges: string[];
    gaps: string[];
  }> {
    const systemMessage = `You are an expert code reviewer and developer intent analyzer. Your job is to reverse-engineer the likely intent behind a pull request from its diff and metadata.

Analyze the provided diff and infer:
1. The original prompt or intent that likely led to these changes
2. A concise summary of what the PR accomplishes
3. Your confidence level (0-100) in the intent inference
4. Key changes made (bullet points)
5. Any gaps or missing implementations

Respond in JSON format with these fields: intent, summary, confidence, keyChanges (array), gaps (array).`;

    const prompt = `PR Title: ${title}
PR Body: ${body || 'No description provided'}

Diff:
\`\`\`diff
${diff}
\`\`\`

Please analyze this PR and infer the developer's intent.`;

    const { content } = await this.generateCompletion(prompt, systemMessage, {
      jsonMode: true,
      temperature: 0.2,
    });

    try {
      return JSON.parse(content);
    } catch {
      // Fallback if JSON parsing fails
      return {
        intent: 'Unable to parse intent from diff',
        summary: 'Analysis failed',
        confidence: 0,
        keyChanges: [],
        gaps: ['Analysis parsing failed'],
      };
    }
  }

  async detectAIGeneration(diff: string, title: string, body: string | null): Promise<{
    isAIGenerated: boolean;
    confidence: number;
    signals: Array<{ type: string; indicator: string; score: number; description: string }>;
    reasoning: string;
  }> {
    const systemMessage = `You are an expert at detecting AI-generated code. Analyze the provided PR diff, title, and description to determine if this was likely generated by AI.

Look for these signals:
- Overly verbose or generic variable names
- Perfect code formatting and style consistency
- Generic or template-like comments
- Comprehensive error handling that feels excessive
- Very structured, methodical approach to simple problems
- Patterns typical of LLM code generation

Respond in JSON format with:
- isAIGenerated (boolean)
- confidence (0-100)
- signals (array of objects with type, indicator, score, description)
- reasoning (string explanation)`;

    const prompt = `PR Title: ${title}
PR Body: ${body || 'No description provided'}

Diff:
\`\`\`diff
${diff}
\`\`\`

Analyze this PR for AI generation indicators.`;

    const { content } = await this.generateCompletion(prompt, systemMessage, {
      jsonMode: true,
      temperature: 0.1,
    });

    try {
      return JSON.parse(content);
    } catch {
      return {
        isAIGenerated: false,
        confidence: 0,
        signals: [],
        reasoning: 'Analysis parsing failed',
      };
    }
  }

  async checkVisionAlignment(diff: string, title: string, visionContent: string): Promise<{
    isAligned: boolean;
    score: number;
    alignments: Array<{
      principle: string;
      alignment: 'aligned' | 'neutral' | 'misaligned';
      reasoning: string;
    }>;
  }> {
    const systemMessage = `You are a technical project manager evaluating if a pull request aligns with the project's vision and principles.

Analyze the PR against the project vision document and determine:
1. Overall alignment (boolean)
2. Alignment score (0-100)
3. Specific alignments with different principles

For each principle mentioned in the vision, evaluate:
- aligned: The PR clearly supports this principle
- neutral: The PR doesn't strongly support or contradict this principle  
- misaligned: The PR goes against this principle

Respond in JSON format.`;

    const prompt = `Project Vision:
${visionContent}

---

PR Title: ${title}
PR Changes:
\`\`\`diff
${diff}
\`\`\`

Evaluate alignment between this PR and the project vision.`;

    const { content } = await this.generateCompletion(prompt, systemMessage, {
      jsonMode: true,
      temperature: 0.2,
    });

    try {
      return JSON.parse(content);
    } catch {
      return {
        isAligned: true,
        score: 50,
        alignments: [],
      };
    }
  }

  async scoreQuality(context: {
    diff: string;
    title: string;
    filesChanged: number;
    linesChanged: number;
    hasTests: boolean;
    isFirstTimeContributor: boolean;
  }): Promise<{
    overallScore: number;
    maxScore: number;
    factors: Array<{
      name: string;
      score: number;
      maxScore: number;
      status: 'pass' | 'warning' | 'fail';
      description: string;
    }>;
  }> {
    const systemMessage = `You are a senior code reviewer evaluating PR quality. Score the PR on various factors:

1. Code Quality (0-3): Clean, readable, follows conventions
2. Change Scope (0-2): Reasonable size, focused changes
3. Testing (0-2): Has appropriate tests
4. Documentation (0-2): Updates docs when needed
5. Contributor Experience (0-1): Account for first-time contributor status

Provide scores and justification for each factor. Status should be:
- pass: Good (green)
- warning: Could be better (yellow)  
- fail: Needs improvement (red)

Respond in JSON format.`;

    const prompt = `PR Analysis:
- Title: ${context.title}
- Files Changed: ${context.filesChanged}
- Lines Changed: ${context.linesChanged}
- Has Tests: ${context.hasTests}
- First-time Contributor: ${context.isFirstTimeContributor}

Diff Preview:
\`\`\`diff
${context.diff.substring(0, 2000)}${context.diff.length > 2000 ? '...' : ''}
\`\`\`

Score this PR's quality across all factors.`;

    const { content } = await this.generateCompletion(prompt, systemMessage, {
      jsonMode: true,
      temperature: 0.1,
    });

    try {
      return JSON.parse(content);
    } catch {
      return {
        overallScore: 5,
        maxScore: 10,
        factors: [
          {
            name: 'Analysis Failed',
            score: 0,
            maxScore: 1,
            status: 'fail',
            description: 'Unable to analyze PR quality',
          },
        ],
      };
    }
  }
}